#version 460
#pragma shader_stage(compute)
#extension GL_KHR_shader_subgroup_basic: enable
#extension GL_KHR_shader_subgroup_clustered: enable

layout(local_size_x = 32, local_size_y = 32) in;

#include "../util.glsl"

layout(binding = 0) uniform sampler2D s_hizSrc;
layout(binding = 1) restrict writeonly uniform image2D i_hiz0;
layout(binding = 2) restrict writeonly uniform image2D i_hiz1;
layout(binding = 3) restrict writeonly uniform image2D i_hiz2;
layout(binding = 4) restrict writeonly uniform image2D i_hiz3;
layout(binding = 5) restrict writeonly uniform image2D i_hiz4;
layout(binding = 6) restrict writeonly uniform image2D i_hiz5;
layout(binding = 7) restrict writeonly uniform image2D i_hiz6;

layout(constant_id = 0) const uint HiZSizePacked = 0;
const uint2 HiZSize = uint2(U16FROMU32(HiZSizePacked));
layout(constant_id = 1) const uint MipCount = 0;

// Tile buffer for cross-thread communication of results
shared float sh_temp[gl_WorkGroupSize.x * gl_WorkGroupSize.y];

void storeTemp(uint2 pos, float val) {
	
	sh_temp[pos.x + pos.y * gl_WorkGroupSize.x] = val;
	
}

float loadTemp(uint2 pos) {
	
	return sh_temp[pos.x + pos.y * gl_WorkGroupSize.x];
	
}

void main() {
	
	uint2 lid = mortonOrder(gl_LocalInvocationID.x + gl_LocalInvocationID.y * gl_WorkGroupSize.x);
	uint2 tileOffset = gl_WorkGroupID.xy * gl_WorkGroupSize.xy;
	uint2 gid = tileOffset + lid;
	
	// Handle first two levels with a min sampler
	
	uint2 sourcePos = gid * 4;
	float2 sourcePitch = rcp(float2(HiZSize));
	float minSamples[4];
	minSamples[0] = textureLod(s_hizSrc, (float2(sourcePos) + float2(1.0, 1.0)) * sourcePitch, 0.0).x;
	minSamples[1] = textureLod(s_hizSrc, (float2(sourcePos) + float2(3.0, 1.0)) * sourcePitch, 0.0).x;
	minSamples[2] = textureLod(s_hizSrc, (float2(sourcePos) + float2(1.0, 3.0)) * sourcePitch, 0.0).x;
	minSamples[3] = textureLod(s_hizSrc, (float2(sourcePos) + float2(3.0, 3.0)) * sourcePitch, 0.0).x;
	
	imageStore(i_hiz0, int2(gid * 2 + uint2(0, 0)), float4(minSamples[0], 0.0, 0.0, 0.0));
	imageStore(i_hiz0, int2(gid * 2 + uint2(1, 0)), float4(minSamples[1], 0.0, 0.0, 0.0));
	imageStore(i_hiz0, int2(gid * 2 + uint2(0, 1)), float4(minSamples[2], 0.0, 0.0, 0.0));
	imageStore(i_hiz0, int2(gid * 2 + uint2(1, 1)), float4(minSamples[3], 0.0, 0.0, 0.0));
	
	if (MipCount < 2)
		return;
	
	float minSample = minSamples[0];
	minSample = min(minSample, minSamples[1]);
	minSample = min(minSample, minSamples[2]);
	minSample = min(minSample, minSamples[3]);
	
	imageStore(i_hiz1, int2(gid), float4(minSample, 0.0, 0.0, 0.0));
	
	// Use subgroup ops as much as possible
	
	if (MipCount < 3)
		return;
	
	if (gl_SubgroupSize >= 4) {
		
		minSample = subgroupClusteredMin(minSample, 4);
		if (gl_SubgroupInvocationID % 4 == 0)
			imageStore(i_hiz2, int2(gid / 2), float4(minSample, 0.0, 0.0, 0.0));
		
	} else {
		
		storeTemp(lid, minSample);
		barrier();
		
		if (all(equal(lid % 2, uint2(0)))) {
			
			minSample = min(minSample, loadTemp(lid + uint2(1, 0)));
			minSample = min(minSample, loadTemp(lid + uint2(0, 1)));
			minSample = min(minSample, loadTemp(lid + uint2(1, 1)));
			imageStore(i_hiz2, int2(gid / 2), float4(minSample, 0.0, 0.0, 0.0));
			
		}
		
	}
	
	if (MipCount < 4)
		return;
	
	if (gl_SubgroupSize >= 16) {
		
		minSample = subgroupClusteredMin(minSample, 16);
		if (gl_SubgroupInvocationID % 16 == 0)
			imageStore(i_hiz3, int2(gid / 4), float4(minSample, 0.0, 0.0, 0.0));
		
	} else {
		
		if (all(equal(lid % 2, uint2(0))))
			storeTemp(lid, minSample);
		barrier();
		
		if (all(equal(lid % 4, uint2(0)))) {
			
			minSample = min(minSample, loadTemp(lid + uint2(2, 0)));
			minSample = min(minSample, loadTemp(lid + uint2(0, 2)));
			minSample = min(minSample, loadTemp(lid + uint2(2, 2)));
			imageStore(i_hiz3, int2(gid / 4), float4(minSample, 0.0, 0.0, 0.0));
			
		}
		
	}
	
	if (MipCount < 5)
		return;
	
	if (gl_SubgroupSize >= 64) {
		
		minSample = subgroupClusteredMin(minSample, 64);
		if (gl_SubgroupInvocationID % 64 == 0)
			imageStore(i_hiz4, int2(gid / 8), float4(minSample, 0.0, 0.0, 0.0));
		
	} else {
		
		if (all(equal(lid % 4, uint2(0))))
			storeTemp(lid, minSample);
		barrier();
		
		if (all(equal(lid % 8, uint2(0)))) {
			
			minSample = min(minSample, loadTemp(lid + uint2(4, 0)));
			minSample = min(minSample, loadTemp(lid + uint2(0, 4)));
			minSample = min(minSample, loadTemp(lid + uint2(4, 4)));
			imageStore(i_hiz4, int2(gid / 8), float4(minSample, 0.0, 0.0, 0.0));
			
		}
		
	}
	
	// Workgroup-only pass
	
	if (MipCount < 6)
		return;
	
	if (all(equal(lid % 8, uint2(0))))
		storeTemp(lid, minSample);
	barrier();
	
	if (all(equal(lid % 16, uint2(0)))) {
		
		minSample = min(minSample, loadTemp(lid + uint2(8, 0)));
		minSample = min(minSample, loadTemp(lid + uint2(0, 8)));
		minSample = min(minSample, loadTemp(lid + uint2(8, 8)));
		imageStore(i_hiz5, int2(gid / 16), float4(minSample, 0.0, 0.0, 0.0));
		
	}
	
	// Workgroup-only pass
	
	if (MipCount < 7)
		return;
	
	if (all(equal(lid % 16, uint2(0))))
		storeTemp(lid, minSample);
	barrier();
	
	if (all(equal(lid /* % 32 */, uint2(0)))) {
		
		minSample = min(minSample, loadTemp(lid + uint2(16, 0)));
		minSample = min(minSample, loadTemp(lid + uint2(0, 16)));
		minSample = min(minSample, loadTemp(lid + uint2(16, 16)));
		imageStore(i_hiz6, int2(gid / 32), float4(minSample, 0.0, 0.0, 0.0));
		
	}
	
}
