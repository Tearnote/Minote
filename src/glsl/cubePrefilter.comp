// Copyright 2016 Activision Publishing, Inc.
// 
// Permission is hereby granted, free of charge, to any person obtaining 
// a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation 
// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
// and/or sell copies of the Software, and to permit persons to whom the Software 
// is furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all 
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
// SOFTWARE.

#version 460
#pragma shader_stage(compute)

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "util.glsl"

layout(binding = 0) uniform samplerCube s_source;
layout(binding = 1) restrict writeonly uniform image2DArray i_target;

layout(constant_id = 0) const uint TargetSize = 0;

void get_dir_0(out vec3 _dir, float _u, float _v) {
	
	_dir[0] = 1;
	_dir[1] = _v;
	_dir[2] = -_u;
	
}

void get_dir_1(out vec3 _dir, in float _u, in float _v) {
	
	_dir[0] = -1;
	_dir[1] = _v;
	_dir[2] = _u;
	
}

void get_dir_2(out vec3 _dir, float _u, float _v) {
	
	_dir[0] = _u;
	_dir[1] = 1;
	_dir[2] = -_v;
	
}

void get_dir_3(out vec3 _dir, float _u, float _v) {
	
	_dir[0] = _u;
	_dir[1] = -1;
	_dir[2] = _v;
	
}

void get_dir_4(out vec3 _dir, float _u, float _v) {
	
	_dir[0] = _u;
	_dir[1] = _v;
	_dir[2] = 1;
	
}

void get_dir_5(out vec3 _dir, float _u, float _v) {
	
	_dir[0] = -_u;
	_dir[1] = _v;
	_dir[2] = -1;
	
}

float calcWeight(float _u, float _v) {
	
	float val = _u*_u + _v*_v + 1;
	return val * sqrt(val);
	
}

void main() {
	
	uvec3 gid = gl_GlobalInvocationID;
	float inv_res_lo = 1.0 / float(TargetSize);
	
	float u0 = (float(gid.x) * 2.0 + 1.0 - 0.75) * inv_res_lo - 1.0;
	float u1 = (float(gid.x) * 2.0 + 1.0 + 0.75) * inv_res_lo - 1.0;
	
	float v0 = (float(gid.y) * 2.0 + 1.0 - 0.75) * -inv_res_lo + 1.0;
	float v1 = (float(gid.y) * 2.0 + 1.0 + 0.75) * -inv_res_lo + 1.0;
	
	float weights[4] = {
		calcWeight(u0, v0),
		calcWeight(u1, v0),
		calcWeight(u0, v1),
		calcWeight(u1, v1)};
	
	float wsum = 0.5 / (weights[0] + weights[1] + weights[2] + weights[3]);
	for (uint i = 0; i < 4; i += 1)
		weights[i] = weights[i] * wsum + 0.125;
	
	vec3 dir;
	vec4 color;
	switch (gid.z) {
		
	case 0:
		get_dir_0(dir, u0, v0);
		color = textureLod(s_source, dir, 0) * weights[0];
		
		get_dir_0(dir, u1, v0);
		color += textureLod(s_source, dir, 0) * weights[1];
		
		get_dir_0(dir, u0, v1);
		color += textureLod(s_source, dir, 0) * weights[2];
		
		get_dir_0(dir, u1, v1);
		color += textureLod(s_source, dir, 0) * weights[3];
		break;
		
	case 1:
		get_dir_1(dir, u0, v0);
		color = textureLod(s_source, dir, 0) * weights[0];
		
		get_dir_1(dir, u1, v0);
		color += textureLod(s_source, dir, 0) * weights[1];
		
		get_dir_1(dir, u0, v1);
		color += textureLod(s_source, dir, 0) * weights[2];
		
		get_dir_1(dir, u1, v1);
		color += textureLod(s_source, dir, 0) * weights[3];
		break;
		
	case 2:
		get_dir_2(dir, u0, v0);
		color = textureLod(s_source, dir, 0) * weights[0];
		
		get_dir_2(dir, u1, v0);
		color += textureLod(s_source, dir, 0) * weights[1];
		
		get_dir_2(dir, u0, v1);
		color += textureLod(s_source, dir, 0) * weights[2];
		
		get_dir_2(dir, u1, v1);
		color += textureLod(s_source, dir, 0) * weights[3];
		break;
		
	case 3:
		get_dir_3(dir, u0, v0);
		color = textureLod(s_source, dir, 0) * weights[0];
		
		get_dir_3(dir, u1, v0);
		color += textureLod(s_source, dir, 0) * weights[1];
		
		get_dir_3(dir, u0, v1);
		color += textureLod(s_source, dir, 0) * weights[2];
		
		get_dir_3(dir, u1, v1);
		color += textureLod(s_source, dir, 0) * weights[3];
		break;
		
	case 4:
		get_dir_4(dir, u0, v0);
		color = textureLod(s_source, dir, 0) * weights[0];
		
		get_dir_4(dir, u1, v0);
		color += textureLod(s_source, dir, 0) * weights[1];
		
		get_dir_4(dir, u0, v1);
		color += textureLod(s_source, dir, 0) * weights[2];
		
		get_dir_4(dir, u1, v1);
		color += textureLod(s_source, dir, 0) * weights[3];
		break;
		
	default:
		get_dir_5(dir, u0, v0);
		color = textureLod(s_source, dir, 0) * weights[0];
		
		get_dir_5(dir, u1, v0);
		color += textureLod(s_source, dir, 0) * weights[1];
		
		get_dir_5(dir, u0, v1);
		color += textureLod(s_source, dir, 0) * weights[2];
		
		get_dir_5(dir, u1, v1);
		color += textureLod(s_source, dir, 0) * weights[3];
		break;
		
	}
	
	imageStore(i_target, ivec3(gid), color);
	
}
