#version 460
#pragma shader_stage(compute)
#extension GL_GOOGLE_include_directive: enable

layout(local_size_x = 8, local_size_y = 8) in;

#include "types.glsl"
#include "util.glsl"

layout(binding = 0) uniform WorldConstants {
	World u_world;
};
layout(binding = 1) uniform usampler2DMS s_visbuf;
layout(binding = 2) restrict writeonly uniform uimage2D i_quadResolve;

layout(push_constant) uniform Constants {
	uvec2 u_sourceSize;
};

#define SUBSAMPLE_COUNT 8
#define K_MEANS_ITERATIONS 1
#define VIS_SAMPLE_COUNT (2 * 2 * SUBSAMPLE_COUNT)

const vec2 SubsampleLocations[SUBSAMPLE_COUNT] = {
	{0.5625, 0.3125},
	{0.4375, 0.6875},
	{0.8125, 0.5625},
	{0.3125, 0.1875},
	{0.1875, 0.8125},
	{0.0625, 0.4375},
	{0.6875, 0.9375},
	{0.9375, 0.0625}};

const uvec2 QuadPixelOffsets[4] = {
	{0, 0},
	{1, 0},
	{0, 1},
	{1, 1}};

void readVisSamples(out uint _visSamples[VIS_SAMPLE_COUNT]) {
	
	uvec2 gid = gl_GlobalInvocationID.xy * 2;
	
	for (uint i = 0; i < VIS_SAMPLE_COUNT; i += 1)
		_visSamples[i] = texelFetch(s_visbuf, ivec2(gid + QuadPixelOffsets[i / SUBSAMPLE_COUNT]), int(i % SUBSAMPLE_COUNT)).x;
	
}

void assignInitialClusterValues(uint _visSamples[VIS_SAMPLE_COUNT], out uint _clusterValues[4]) {
	
	uint clusterValueFreqs[4];
	
	for (uint i = 0; i < 4; i += 1) {
		
		_clusterValues[i] = -2u;
		clusterValueFreqs[i] = 0;
		
	}
	
	uint uniqueValues = 0;
	for (uint i = 0; i < VIS_SAMPLE_COUNT; i += 1) {
		
		// If repeat, increment frequency
		// Check if value is unique
		
		
		bool unique = true;
		for (uint j = 0; j < 4; j += 1) {
			
			if (_visSamples[i] == _clusterValues[j]) {
				
				clusterValueFreqs[j] += 1;
				unique = false;
				
			}
			
		}
		
		// If unique, add to list
		
		if (unique) {
			
			// Check if too many unique values
			
			if (uniqueValues < 4) {
				
				_clusterValues[uniqueValues] = _visSamples[i];
				clusterValueFreqs[uniqueValues] = 1;
				
			}
			
			uniqueValues += 1;
			
			
		}
		
	}
	
	// Assign initial cluster values
	
	if (uniqueValues >= 4) {
		
		uint initialSubsample = u_world.frameCounter % SUBSAMPLE_COUNT;
		for (uint i = 0; i < 4; i += 1)
			_clusterValues[i] = _visSamples[i * SUBSAMPLE_COUNT + initialSubsample];
		
	} else {
		
		// Find highest frequency cluster
		
		uint highestFreq = 0;
		uint highestFreqIdx = 0;
		for (uint i = 0; i < 4; i += 1) {
			
			if (clusterValueFreqs[i] > highestFreq) {
				
				highestFreq = clusterValueFreqs[i];
				highestFreqIdx = i;
				
			}
			
		}
		
		// Duplicate samples to any unassigned clusters
		
		for (uint i = 0; i < 4; i += 1) {
			
			if (_clusterValues[i] == -2u)
				_clusterValues[i] = _clusterValues[highestFreqIdx];
			
		}
		
	}
	
}

void kMeansClustering(uint _visValues[VIS_SAMPLE_COUNT], uint _clusterValues[4],
	out uint _clusterSubsamples[4], uint _iterations) {
	
	vec2 clusterCentroids[4];
	for (uint i = 0; i < 4; i += 1)
		clusterCentroids[i] = vec2(QuadPixelOffsets[i]) + vec2(0.5);
	
	for (uint it = 0; it < _iterations; it += 1) {
		
		vec2 newCentroids[4];
		for (uint i = 0; i < 4; i += 1) {
			
			newCentroids[i] = vec2(0.0);
			_clusterSubsamples[i] = 0;
			
		}
		
		for (uint subIdx = 0; subIdx < VIS_SAMPLE_COUNT; subIdx += 1) {
			
			uint quadPx = subIdx / SUBSAMPLE_COUNT;
			vec2 subsamplePosition = vec2(QuadPixelOffsets[quadPx]) + SubsampleLocations[subIdx % SUBSAMPLE_COUNT];
			uint subsampleValue = _visValues[subIdx];
			
			// Compute distance from each cluster
			
			float distances[4];
			for (uint i = 0; i < 4; i += 1) {
				
				float dist2 = distanceSq(subsamplePosition, clusterCentroids[i]);
				float primitiveBias = log2(max(_clusterValues[i], subsampleValue) - min(_clusterValues[i], subsampleValue) + 1) * 4.0;
				distances[i] = dist2 + primitiveBias;
				
			}
			
			// Find closest cluster
			
			uint closestClusterIdx = 0;
			float closestClusterDist = distances[0];
			for (uint i = 1; i < 4; i += 1) {
				
				if (distances[i] < closestClusterDist) {
					
					closestClusterIdx = i;
					closestClusterDist = distances[i];
					
				}
				
			}
			
			// Add subsample to closest cluster
			
			newCentroids[closestClusterIdx] += subsamplePosition;
			_clusterSubsamples[closestClusterIdx] |= 1 << subIdx;
			
		}
		
		for (uint i = 0; i < 4; i += 1)
			clusterCentroids[i] = newCentroids[i] / float(bitCount(_clusterSubsamples[i]));
		
	}
	
}

void main() {
	
	uint visSamples[VIS_SAMPLE_COUNT];
	readVisSamples(visSamples);
	
	uint clusterValues[4];
	assignInitialClusterValues(visSamples, clusterValues);
	
	uint clusterSubsamples[4];
	kMeansClustering(visSamples, clusterValues, clusterSubsamples, K_MEANS_ITERATIONS);
	
	for (uint i = 0; i < 4; i += 1)
		imageStore(i_quadResolve, ivec2(gl_GlobalInvocationID.xy * 2 + QuadPixelOffsets[i]), uvec4(clusterValues[i], clusterSubsamples[i], 0, 0));
	
}
