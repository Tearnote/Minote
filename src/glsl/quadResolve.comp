#version 460
#pragma shader_stage(compute)

layout(local_size_x = 8, local_size_y = 8) in;

#include "types.glsl"
#include "util.glsl"

layout(binding = 0) uniform WorldConstants {
	World u_world;
};
layout(binding = 1) uniform usampler2D s_quadbuf;
layout(binding = 2) uniform sampler2D s_clusterOut;
layout(binding = 3) uniform sampler2D s_history;
layout(binding = 4) restrict writeonly uniform image2D i_target;

layout(push_constant) uniform Constants {
	uvec2 u_sourceSize;
};

#define SUBSAMPLE_COUNT 8
#define VIS_SAMPLE_COUNT (4 * SUBSAMPLE_COUNT)

const uvec2 QuadPixelOffsets[4] = {
	{0, 0},
	{1, 0},
	{0, 1},
	{1, 1}};

void main() {
	
	uvec2 gid = gl_GlobalInvocationID.xy * 2;
	
	// Read quad and cluster output samples
	
	uint clusterSubsamples[4];
	mat4 clusterOuts;
	for (uint i = 0; i < 4; i += 1) {
		
		clusterSubsamples[i] = texelFetch(s_quadbuf, ivec2(gid + QuadPixelOffsets[i]), 0).y;
		clusterOuts[i] = texelFetch(s_clusterOut, ivec2(gid + QuadPixelOffsets[i]), 0);
		
	}
	
	// Read history samples
	
	mat4 historySamples;
	for (uint i = 0; i < 4; i += 1)
		historySamples[i] = texelFetch(s_history, ivec2(gid + QuadPixelOffsets[i]), 0);
	
	// Calculate each cluster's contribution to each pixel
	
	const float WeightStep = 1.0 / float(SUBSAMPLE_COUNT);
	mat4 clusterWeights;
	for (uint i = 0; i < 4; i += 1) {
		
		uint mask = bitmask(SUBSAMPLE_COUNT) << (i * SUBSAMPLE_COUNT);
		for (uint j = 0; j < 4; j += 1)
			clusterWeights[i][j] = float(bitCount(clusterSubsamples[j] & mask)) * WeightStep;
		
	}
	
	// Blend together the cluster contributions
	
	mat4 currentSamples = clusterOuts * clusterWeights;
	
	// Write out the result
	
	float blendRatio = (1.0 / float(SUBSAMPLE_COUNT)) * (SUBSAMPLE_COUNT - min(u_world.frameCounter - 1, SUBSAMPLE_COUNT - 1));
	for (uint i = 0; i < 4; i += 1) {
		
		vec4 result = mix(historySamples[i], currentSamples[i], blendRatio);
		imageStore(i_target, ivec2(gid + QuadPixelOffsets[i]), result);
		
	}
	
}
