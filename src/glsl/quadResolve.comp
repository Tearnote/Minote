#version 460
#pragma shader_stage(compute)

layout(local_size_x = 8, local_size_y = 8) in;

#include "types.glsl"
#include "quad.glsl"
#include "util.glsl"

layout(binding = 0) uniform WorldConstants {
	World u_world;
};
layout(binding = 1) uniform usampler2D s_clusterDef;
layout(binding = 2) uniform usampler2D s_jitterMap;
layout(binding = 3) uniform sampler2D s_clusterOut;
layout(binding = 4) uniform sampler2D s_outputPrev;
layout(binding = 5) uniform usampler2D s_clusterDefPrev;
layout(binding = 6) uniform sampler2D s_clusterOutPrev;
layout(binding = 7) uniform usampler2D s_jitterMapPrev;
layout(binding = 8) uniform sampler2D s_velocity;
layout(binding = 9) restrict writeonly uniform image2D i_output;

layout(constant_id = 0) const uint u_sourceSizePacked = 0;
const uvec2 u_sourceSize = U16FROMU32(u_sourceSizePacked);

#define CONVERGE_FRAMES 15
#define TAA_DEBUG 0

bool isQuadJittered(usampler2D _map, uvec2 _gid) {
	
	uint jitterSample = texelFetch(_map, ivec2(_gid / 8), 0).r;
	uvec2 quadOffset = (_gid / 2) % 4;
	uint quadMask = 1u << (quadOffset.x + quadOffset.y * 4);
	return (jitterSample & quadMask) != 0;
	
}

// https://research.activision.com/publications/archives/filmic-smaasharp-morphological-and-temporal-antialiasing
#define REPROJECTION_SHARPNESS 25.0
vec4 sampleHistory(vec2 _uv) {
	
	const vec2 sourcePxPitch = vec2(1.0) / vec2(u_sourceSize);
	
	vec2 centerPosition = floor(_uv - 0.5) + 0.5;
	vec2 f = _uv - centerPosition;
	vec2 f2 = f * f;
	vec2 f3 = f * f2;
	
	float c = REPROJECTION_SHARPNESS / 100.0;
	vec2 w0 =        -c  * f3 +  2.0 * c         * f2 - c * f;
	vec2 w1 =  (2.0 - c) * f3 - (3.0 - c)        * f2         + 1.0;
	vec2 w2 = -(2.0 - c) * f3 + (3.0 -  2.0 * c) * f2 + c * f;
	vec2 w3 =         c  * f3 -                c * f2;
	
	vec2 w12 = w1 + w2;
	vec2 tc12 = sourcePxPitch * (centerPosition + w2 / w12);
	vec4 centerColor = textureLod(s_outputPrev, vec2(tc12.x, tc12.y), 0.0);
	
	vec2 tc0 = sourcePxPitch * (centerPosition - 1.0);
	vec2 tc3 = sourcePxPitch * (centerPosition + 2.0);
	vec3 color = textureLod(s_outputPrev, vec2(tc12.x, tc0.y ), 0.0).rgb * (w12.x * w0.y ) +
	             textureLod(s_outputPrev, vec2(tc0.x,  tc12.y), 0.0).rgb * (w0.x  * w12.y) +
	             centerColor.rgb                                         * (w12.x * w12.y) +
	             textureLod(s_outputPrev, vec2(tc3.x,  tc12.y), 0.0).rgb * (w3.x  * w12.y) +
	             textureLod(s_outputPrev, vec2(tc12.x, tc3.y ), 0.0).rgb * (w12.x * w3.y );
	return vec4(color.rgb, centerColor.a);
	
}

void main() {
	
	uvec2 gid = gl_GlobalInvocationID.xy * 2;
	
	// Read quad and cluster output samples
	
	uvec4 clusterValues;
	uvec4 clusterSubsamples;
	mat4x3 clusterOuts;
	mat4x2 clusterVelocities;
	for (uint i = 0; i < 4; i += 1) {
		
		uvec2 cluster = texelFetch(s_clusterDef, ivec2(gid + QuadPixelOffsets[i]), 0).xy;
		clusterValues[i] = cluster.x;
		clusterSubsamples[i] = cluster.y;
		clusterOuts[i] = texelFetch(s_clusterOut, ivec2(gid + QuadPixelOffsets[i]), 0).rgb;
		clusterVelocities[i] = texelFetch(s_velocity, ivec2(gid + QuadPixelOffsets[i]), 0).xy;
		
	}
	
	// For each pixel, perform TAA
	
	for (uint i = 0; i < 4; i += 1) {
		
		// Calculate each cluster's contribution to current pixel
		
		const float WeightStep = 1.0 / float(SUBSAMPLE_COUNT);
		uint mask = bitmask(SUBSAMPLE_COUNT) << (i * SUBSAMPLE_COUNT);
		vec4 clusterWeights;
		for (uint j = 0; j < 4; j += 1)
			clusterWeights[j] = float(bitCount(clusterSubsamples[j] & mask)) * WeightStep;
		
		// Blend together the cluster contributions to obtain current sample
		
		vec3 currentSample = vec3(0.0);
		for (uint j = 0; j < 4; j += 1)
			currentSample += tonemapWithWeight(clusterOuts[j], clusterWeights[j]);
		currentSample = tonemapInvert(currentSample);
		
		// Reproject to get history position
		
		vec2 currentLocation = vec2(gid + QuadPixelOffsets[i]) + vec2(0.5);
		vec2 historyLocation = currentLocation - clusterVelocities[i];
		uvec2 historyQuad = uvec2(historyLocation) & ~1u;
		
		// Check how many history clusters are usable
		
		bool validHistoryClusters[4] = {false, false, false, false};
		uvec4 historyValues;
		uvec4 historySubsamples;
		
		// OOB test
		
		bool doesJitter = false;
		bool didJitter = false;
		if (all(greaterThanEqual(historyLocation, vec2(0.0))) && all(lessThan(historyLocation, vec2(u_sourceSize)))) {
			
			// Current jitter test
			
			doesJitter = isQuadJittered(s_jitterMap, uvec2(currentLocation));
			didJitter = isQuadJittered(s_jitterMapPrev, uvec2(historyLocation));
			
			if (doesJitter && didJitter) {
				
				validHistoryClusters = bool[](true, true, true, true);
				
			// History jitter test
				
			} else {
				
				// Go over each history cluster and check if it's valid
				
				for (uint j = 0; j < 4; j += 1) {
					
					uvec2 historyCluster = texelFetch(s_clusterDefPrev, ivec2(historyQuad + QuadPixelOffsets[j]), 0).xy;
					historyValues[j] = historyCluster.x;
					historySubsamples[j] = historyCluster.y;
					
					for (uint k = 0; k < 4; k += 1) {
						
						if (historyValues[j] == clusterValues[k]) {
							
							validHistoryClusters[j] = true;
							break;
							
						}
						
					}
					
				}
				
			}
			
		}
		
		vec4 result; // .a is age
		
		uint resultType;
		
		// All clusters valid? Sample the history
		
		if (validHistoryClusters[0] &&
		    validHistoryClusters[1] &&
		    validHistoryClusters[2] &&
		    validHistoryClusters[3] &&
		   (doesJitter == didJitter)) {
			
			resultType = 0;
			
			vec4 historySample = sampleHistory(historyLocation);
			uint historySampleAge = uint(historySample.a);
			float blendRatio = (1.0 / float(CONVERGE_FRAMES)) * (CONVERGE_FRAMES - min(historySampleAge, CONVERGE_FRAMES - 1));
			uint newAge = min(historySampleAge + 1, CONVERGE_FRAMES - 1);
			result = vec4(mix(historySample.rgb, currentSample, blendRatio), float(newAge));
			
		// No clusters valid? Use current sample only, reset age
			
		} else if (!validHistoryClusters[0] &&
		           !validHistoryClusters[1] &&
		           !validHistoryClusters[2] &&
		           !validHistoryClusters[3]) {
			
			resultType = 1;
			
			result = vec4(currentSample, 1.0);
			
		// Some clusters valid? Create a history pixel from valid history clusters
			
		} else {
			
			resultType = 2;
			
			// Normalize weights of valid history clusters
			
			float validHistoryWeightSum = 0.0;
			vec4 historyWeights = vec4(0.0);
			for (uint j = 0; j < 4; j += 1) {
				
				if (validHistoryClusters[j]) {
					
					historyWeights[j] = float(bitCount(historySubsamples[j])) * WeightStep;
					validHistoryWeightSum += historyWeights[j];
					
				}
				
			}
			
			for (uint j = 0; j < 4; j += 1)
				historyWeights[j] /= validHistoryWeightSum;
			
			// Fetch history cluster results
			
			mat4x3 historyOuts;
			for (uint j = 0; j < 4; j += 1)
				historyOuts[j] = texelFetch(s_clusterOutPrev, ivec2(historyQuad + QuadPixelOffsets[j]), 0).rgb;
			
			// Create a history pixel from new weights
			
			vec3 historySample = vec3(0.0);
			for (uint j = 0; j < 4; j += 1)
				historySample += tonemapWithWeight(historyOuts[j], historyWeights[j]);
			historySample = tonemapInvert(historySample);
			
			// Blend history pixel with current
			
			const float blendRatio = (1.0 / float(CONVERGE_FRAMES)) * (CONVERGE_FRAMES - 1);
			result = vec4(mix(historySample.rgb, currentSample, blendRatio), 2.0);
			
		}
		
#if TAA_DEBUG
		switch (resultType) {
			
			case 0:
			result.rgb = vec3(0.389, 0.625, 0.774);
			break;
			case 1:
			result.rgb = vec3(0.900, 0.145, 0.160);
			break;
			case 2:
			result.rgb = vec3(0.010, 0.190, 0.465);
			break;
			
		}
#endif //TAA_DEBUG
		
		// Dither and write out
		
		uvec2 pos = gid + uvec2(QuadPixelOffsets[i]);
		uint seed = u_sourceSize.x * u_sourceSize.y * u_world.frameCounter + pos.x * u_sourceSize.y + pos.y;
		result += (randFloat(seed) * 2.0 - 1.0) * 0.0005;
		result = max(result, 0.0);
		
		imageStore(i_output, ivec2(gid + QuadPixelOffsets[i]), result);
		
	}
	
}
