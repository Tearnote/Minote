#version 460
#pragma shader_stage(compute)

layout(local_size_x = 8, local_size_y = 8) in;

#include "types.glsl"
#include "quad.glsl"
#include "util.glsl"

layout(binding = 0) uniform WorldConstants {
	World u_world;
};
layout(binding = 1) uniform usampler2D s_quadbuf;
layout(binding = 2) uniform sampler2D s_clusterOut;
layout(binding = 3) uniform sampler2D s_history;
layout(binding = 4) uniform usampler2D s_quadbufPrev;
layout(binding = 5) uniform sampler2D s_clusterOutPrev;
layout(binding = 6) uniform sampler2D s_velocity;
layout(binding = 7) restrict writeonly uniform image2D i_target;

layout(push_constant) uniform Constants {
	uvec2 u_sourceSize;
};

bool shouldReject(float _depth, vec2 _historyUv) {
	
	uvec2 quadGid = uvec2(_historyUv) & ~1u;
	vec2 quadUv = _historyUv - vec2(quadGid);
	
	// Read quad data and find centroids
	
	vec4 prevClusterDepths;
	mat4x2 prevClusterCentroids;
	
	for (uint i = 0; i < 4; i += 1) {
		
		prevClusterDepths[i] = texelFetch(s_clusterOutPrev, ivec2(quadGid + QuadPixelOffsets[i]), 0).a;
		uint prevClusterSubsample = texelFetch(s_quadbufPrev, ivec2(quadGid + QuadPixelOffsets[i]), 0).y;
		prevClusterCentroids[i] = subsamplePosAverage(prevClusterSubsample);
		
	}
	
	// Find the closest cluster
	
	uint closestCluster = 0;
	float smallestDistanceSq = distanceSq(quadUv, prevClusterCentroids[0]);
	for (uint i = 1; i < 4; i += 1) {
		
		float distanceSq = distanceSq(quadUv, prevClusterCentroids[i]);
		if (distanceSq < smallestDistanceSq) {
			
			smallestDistanceSq = distanceSq;
			closestCluster = i;
			
		}
		
	}
	
	// Reject if the depth is too far from the closest cluster
	
	float closestDepth = prevClusterDepths[closestCluster];
	
	if (closestDepth == 0.0)
		return true;
	
	float depthDelta = abs(_depth - closestDepth);
	if (depthDelta > 0.001)
		return true;
	
	return false;
	
};

// https://research.activision.com/publications/archives/filmic-smaasharp-morphological-and-temporal-antialiasing
#define REPROJECTION_SHARPNESS 25.0
vec4 sampleHistory(vec2 _uv, vec4 _metrics) {
	
	vec2 centerPosition = floor(_uv - 0.5) + 0.5;
	vec2 f = _uv - centerPosition;
	vec2 f2 = f * f;
	vec2 f3 = f * f2;
	
	float c = REPROJECTION_SHARPNESS / 100.0;
	vec2 w0 =        -c  * f3 +  2.0 * c         * f2 - c * f;
	vec2 w1 =  (2.0 - c) * f3 - (3.0 - c)        * f2         + 1.0;
	vec2 w2 = -(2.0 - c) * f3 + (3.0 -  2.0 * c) * f2 + c * f;
	vec2 w3 =         c  * f3 -                c * f2;
	
	vec2 w12 = w1 + w2;
	vec2 tc12 = _metrics.xy * (centerPosition + w2 / w12);
	vec4 centerColor = textureLod(s_history, vec2(tc12.x, tc12.y), 0.0);
	
	vec2 tc0 = _metrics.xy * (centerPosition - 1.0);
	vec2 tc3 = _metrics.xy * (centerPosition + 2.0);
	vec4 color = vec4(textureLod(s_history, vec2(tc12.x, tc0.y ), 0.0).rgb, 1.0) * (w12.x * w0.y ) +
	             vec4(textureLod(s_history, vec2(tc0.x,  tc12.y), 0.0).rgb, 1.0) * (w0.x  * w12.y) +
	             vec4(centerColor.rgb,                                      1.0) * (w12.x * w12.y) +
	             vec4(textureLod(s_history, vec2(tc3.x,  tc12.y), 0.0).rgb, 1.0) * (w3.x  * w12.y) +
	             vec4(textureLod(s_history, vec2(tc12.x, tc3.y ), 0.0).rgb, 1.0) * (w12.x * w3.y );
	return vec4(color.rgb, centerColor.a);
	
}

void main() {
	
	uvec2 gid = gl_GlobalInvocationID.xy * 2;
	vec4 targetMetrics = vec4(vec2(1.0) / vec2(u_sourceSize), vec2(u_sourceSize));
	
	// Read quad and cluster output samples
	
	uvec4 clusterSubsamples;
	mat4 clusterOuts;
	mat4x2 clusterVelocities;
	for (uint i = 0; i < 4; i += 1) {
		
		clusterSubsamples[i] = texelFetch(s_quadbuf, ivec2(gid + QuadPixelOffsets[i]), 0).y;
		clusterOuts[i] = texelFetch(s_clusterOut, ivec2(gid + QuadPixelOffsets[i]), 0);
		clusterVelocities[i] = texelFetch(s_velocity, ivec2(gid + QuadPixelOffsets[i]), 0).xy;
		
	}
	
	// Reproject from the history buffer
	
	mat4 historySamples; // .a is sample age
	for (uint i = 0; i < 4; i += 1) {
		
		vec2 currentLocation = vec2(gid + QuadPixelOffsets[i]) + vec2(0.5);
		vec2 historyLocation = currentLocation - clusterVelocities[i];
		if (any(lessThan(historyLocation, vec2(0.0))) || any(greaterThan(historyLocation, vec2(u_sourceSize))) ||
			shouldReject(clusterOuts[i].a, historyLocation))
			historySamples[i] = vec4(0.0);
		else
			historySamples[i] = sampleHistory(historyLocation, targetMetrics);
		
	}
	
	// Calculate each cluster's contribution to each pixel
	
	const float WeightStep = 1.0 / float(SUBSAMPLE_COUNT);
	mat4 clusterWeights;
	for (uint i = 0; i < 4; i += 1) {
		
		uint mask = bitmask(SUBSAMPLE_COUNT) << (i * SUBSAMPLE_COUNT);
		for (uint j = 0; j < 4; j += 1)
			clusterWeights[i][j] = float(bitCount(clusterSubsamples[j] & mask)) * WeightStep;
		
	}
	
	// Blend together the cluster contributions
	
	mat4 currentSamples = clusterOuts * clusterWeights;
	
	// Reproject from previous frame, do temporal blending, and write out the result
	
	for (uint i = 0; i < 4; i += 1) {
		
		uint historySampleAge = uint(historySamples[i].a);
		float blendRatio = (1.0 / float(SUBSAMPLE_COUNT)) * (SUBSAMPLE_COUNT - min(historySampleAge, SUBSAMPLE_COUNT - 1));
		uint newAge = min(historySampleAge + 1, SUBSAMPLE_COUNT - 1);
		vec3 result = mix(historySamples[i].rgb, currentSamples[i].rgb, blendRatio);
		
		uvec2 pos = gid + uvec2(QuadPixelOffsets[i]);
		uint seed = u_sourceSize.x * u_sourceSize.y * u_world.frameCounter + pos.x * u_sourceSize.y + pos.y;
		result += (randFloat(seed) * 2.0 - 1.0) * 0.0005;
		
		imageStore(i_target, ivec2(gid + QuadPixelOffsets[i]), vec4(result, float(newAge)));
		
	}
	
}
