#version 460
#pragma shader_stage(compute)

layout(local_size_x = 8, local_size_y = 8) in;

#include "types.glsl"
#include "quad.glsl"
#include "util.glsl"

layout(binding = 0) uniform WorldConstants {
	World u_world;
};
layout(binding = 1) uniform usampler2D s_hash;
layout(binding = 2) uniform usampler2D s_subsamples;
layout(binding = 3) uniform usampler2D s_jitterMap;
layout(binding = 4) uniform sampler2D s_clusterOut;
layout(binding = 5) uniform sampler2D s_outputPrev;
layout(binding = 6) uniform usampler2D s_hashPrev;
layout(binding = 7) uniform usampler2D s_subsamplesPrev;
layout(binding = 8) uniform sampler2D s_clusterOutPrev;
layout(binding = 9) uniform usampler2D s_jitterMapPrev;
layout(binding = 10) uniform sampler2D s_velocity;
layout(binding = 11) restrict writeonly uniform image2D i_output;

layout(constant_id = 0) const uint u_sourceSizePacked = 0;
const uvec2 u_sourceSize = U16FROMU32(u_sourceSizePacked);

#define CONVERGE_FRAMES 15

bool isQuadJittered(usampler2D _map, uvec2 _gid) {
	
	uint jitterSample = texelFetch(_map, ivec2(_gid / 8), 0).r;
	uvec2 quadOffset = (_gid / 2) % 4;
	uint quadMask = 1u << (quadOffset.x + quadOffset.y * 4);
	return (jitterSample & quadMask) != 0;
	
}

// https://research.activision.com/publications/archives/filmic-smaasharp-morphological-and-temporal-antialiasing
#define REPROJECTION_SHARPNESS 25.0
vec4 sampleHistory(vec2 _uv) {
	
	const vec2 sourcePxPitch = vec2(1.0) / vec2(u_sourceSize);
	
	vec2 centerPosition = floor(_uv - 0.5) + 0.5;
	vec2 f = _uv - centerPosition;
	vec2 f2 = f * f;
	vec2 f3 = f * f2;
	
	float c = REPROJECTION_SHARPNESS / 100.0;
	vec2 w0 =        -c  * f3 +  2.0 * c         * f2 - c * f;
	vec2 w1 =  (2.0 - c) * f3 - (3.0 - c)        * f2         + 1.0;
	vec2 w2 = -(2.0 - c) * f3 + (3.0 -  2.0 * c) * f2 + c * f;
	vec2 w3 =         c  * f3 -                c * f2;
	
	vec2 w12 = w1 + w2;
	vec2 tc12 = sourcePxPitch * (centerPosition + w2 / w12);
	vec4 centerColor = textureLod(s_outputPrev, vec2(tc12.x, tc12.y), 0.0);
	
	vec2 tc0 = sourcePxPitch * (centerPosition - 1.0);
	vec2 tc3 = sourcePxPitch * (centerPosition + 2.0);
	vec3 color = textureLod(s_outputPrev, vec2(tc12.x, tc0.y ), 0.0).rgb * (w12.x * w0.y ) +
	             textureLod(s_outputPrev, vec2(tc0.x,  tc12.y), 0.0).rgb * (w0.x  * w12.y) +
	             centerColor.rgb                                         * (w12.x * w12.y) +
	             textureLod(s_outputPrev, vec2(tc3.x,  tc12.y), 0.0).rgb * (w3.x  * w12.y) +
	             textureLod(s_outputPrev, vec2(tc12.x, tc3.y ), 0.0).rgb * (w12.x * w3.y );
	return vec4(color.rgb, centerColor.a);
	
}

void main() {
	
	uvec2 gid = gl_GlobalInvocationID.xy * 2;
	
	// Read quad and cluster output samples
	
	uvec4 clusterValues;
	uvec4 clusterSubsamples;
	mat4x3 clusterOuts;
	mat4x2 clusterVelocities;
	for (uint i = 0; i < 4; i += 1) {
		
		uvec2 pos = gid + uvec2(QuadPixelOffsets[i]);
		clusterValues[i] = texelFetch(s_hash, ivec2(pos), 0).x;
		clusterSubsamples[i] = texelFetch(s_subsamples, ivec2(pos), 0).x;
		clusterOuts[i] = texelFetch(s_clusterOut, ivec2(pos), 0).rgb;
		clusterVelocities[i] = texelFetch(s_velocity, ivec2(pos), 0).xy;
		
	}
	
	// For each pixel, perform TAA
	
	for (uint i = 0; i < 4; i += 1) {
		
		// Calculate each cluster's contribution to current pixel
		
		const float WeightStep = 1.0 / float(SUBSAMPLE_COUNT);
		uint mask = bitmask(SUBSAMPLE_COUNT) << (i * SUBSAMPLE_COUNT);
		vec4 clusterWeights;
		for (uint j = 0; j < 4; j += 1)
			clusterWeights[j] = float(bitCount(clusterSubsamples[j] & mask)) * WeightStep;
		
		// Blend together the cluster contributions to obtain current sample
		
		vec3 currentSample = vec3(0.0);
		for (uint j = 0; j < 4; j += 1)
			currentSample += tonemapWithWeight(clusterOuts[j], clusterWeights[j]);
		currentSample = tonemapInvert(currentSample);
		
		// Reproject to get history position
		
		vec2 currentLocation = vec2(gid + QuadPixelOffsets[i]) + vec2(0.5);
		vec2 historyLocation = currentLocation - clusterVelocities[i];
		uvec2 historyQuad = uvec2(historyLocation) & ~1u;
		
		// History rejection tests
		
		bool reject = true;
		
		// OOB test
		if (all(greaterThanEqual(historyLocation, vec2(0.0))) && all(lessThan(historyLocation, vec2(u_sourceSize)))) {
			
			// Current jitter test
			
			bool doesJitter = isQuadJittered(s_jitterMap, uvec2(currentLocation));
			bool didJitter = isQuadJittered(s_jitterMapPrev, uvec2(historyLocation));
			
			if (doesJitter && didJitter)
				reject = false;
			
		}
		
		vec4 result; // .a is age
		
		// All clusters valid? Sample the history
		
		if (reject) {
			
			result = vec4(currentSample, 1.0);
			
		} else {
			
			vec4 historySample = sampleHistory(historyLocation);
			uint historySampleAge = uint(historySample.a);
			float blendRatio = (1.0 / float(CONVERGE_FRAMES)) * (CONVERGE_FRAMES - min(historySampleAge, CONVERGE_FRAMES - 1));
			uint newAge = min(historySampleAge + 1, CONVERGE_FRAMES - 1);
			result = vec4(mix(historySample.rgb, currentSample, blendRatio), float(newAge));
			
		}
		
		// Dither and write out
		
		uvec2 pos = gid + uvec2(QuadPixelOffsets[i]);
		uint seed = u_sourceSize.x * u_sourceSize.y * u_world.frameCounter + pos.x * u_sourceSize.y + pos.y;
		result += (randFloat(seed) * 2.0 - 1.0) * 0.0005;
		result = max(result, 0.0);
		
		imageStore(i_output, ivec2(gid + QuadPixelOffsets[i]), result);
		
	}
	
}
