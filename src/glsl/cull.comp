#version 460
#pragma shader_stage(compute)

layout(local_size_x = 64) in;

#include "types.glsl"

layout (binding = 0, std430) restrict buffer Commands {
	Command b_commands[];
};
layout (binding = 1, std430) restrict readonly buffer Descriptors {
	MeshDescriptor b_descriptors[];
};
layout (binding = 2, std430) restrict readonly buffer MeshIndices {
	uint b_meshIndices[];
};
layout (binding = 3, std430) restrict readonly buffer Transforms {
	BasicTransform b_transforms[];
};
layout (binding = 4, std430) restrict readonly buffer Materials {
	Material b_materials[];
};
layout (binding = 5, std430) restrict writeonly buffer MeshIndicesCulled {
	uint b_meshIndicesCulled[];
};
layout (binding = 6, std430) restrict writeonly buffer TransformsCulled {
	Transform b_transformsCulled[];
};
layout (binding = 7, std430) restrict writeonly buffer MaterialsCulled {
	Material b_materialsCulled[];
};

layout(push_constant) uniform Constants {
	mat4 u_view;
	vec4 u_frustum;
	uint u_instancesCount;
};

bool visible(uint _gid, float _radius) {
	
	vec3 center = (u_view * vec4(b_transforms[_gid].position, 1.0)).xyz;
	
	bool result = true;
	result = result && center.z * u_frustum[1] - abs(center.x) * u_frustum[0] > -_radius;
	result = result && center.z * u_frustum[3] - abs(center.y) * u_frustum[2] > -_radius;
	
	return result;
	
}

void main() {
	
	uint gid = gl_GlobalInvocationID.x;
	if (gid >= u_instancesCount)
		return;
	
	uint index = b_meshIndices[gid];
	float scale = max(b_transforms[gid].scale.x,
	              max(b_transforms[gid].scale.y,
	                  b_transforms[gid].scale.z));
	float radius = b_descriptors[index].radius;
	if (!visible(gid, radius * scale))
		return;
	
	uint offset = b_commands[index].firstInstance;
	uint newid = offset + atomicAdd(b_commands[index].instanceCount, 1);
	
	b_meshIndicesCulled[newid] = b_meshIndices[gid];
	b_transformsCulled[newid] = encodeTransform(b_transforms[gid]);
	b_materialsCulled[newid] = b_materials[gid];
	
}
