#version 460
#pragma shader_stage(compute)

layout(local_size_x = 64) in;

struct Command {
	uint indexCount;
	uint instanceCount;
	uint firstIndex;
	uint vertexOffset;
	uint firstInstance;
};
layout (binding = 0, std430) buffer Draws {
	Command draws[];
};

struct Descriptor {
	uint indexOffset;
	uint indexCount;
	uint vertexOffset;
	float radius;
};
layout (binding = 1, std430) buffer Descriptors {
	Descriptor descriptors[];
};

struct Material {
	vec4 tint;
	float roughness;
	float metalness;
	vec2 pad0;
};
layout (binding = 2, std430) readonly buffer MeshIndex {
	uint meshIndex[];
};
layout (binding = 3, std430) readonly buffer Transform {
	mat4 transform[];
};
layout (binding = 4, std430) readonly buffer Materials {
	Material material[];
};
layout (binding = 5, std430) writeonly buffer MeshIndexCulled {
	uint meshIndexCulled[];
};
layout (binding = 6, std430) writeonly buffer TransformCulled {
	mat4 transformCulled[];
};
layout (binding = 7, std430) writeonly buffer MaterialsCulled {
	Material materialCulled[];
};

layout(binding = 8) uniform CullData {
	mat4 view;
	vec4 frustum;
	uint instancesCount;
};

float maxScale(mat4 transform) {
	float x = length(vec3(transform[0][0], transform[0][1], transform[0][2]));
	float y = length(vec3(transform[1][0], transform[1][1], transform[1][2]));
	float z = length(vec3(transform[2][0], transform[2][1], transform[2][2]));
	return max(x, max(y, z));
}

bool visible(uint gid, float radius) {
	vec3 center = (view * transform[gid][3]).xyz;

	bool result = true;
	result = result && center.z * frustum[1] - abs(center.x) * frustum[0] > -radius;
	result = result && center.z * frustum[3] - abs(center.y) * frustum[2] > -radius;
	
	return result;
}

void main() {
	const uint gid = gl_GlobalInvocationID.x;
	if (gid >= instancesCount) return;
	
	uint index = meshIndex[gid];
	float scale = maxScale(transform[gid]);
	float radius = descriptors[index].radius;
	if (!visible(gid, radius * scale)) return;
	
	uint offset = draws[index].firstInstance;
	uint newid = offset + atomicAdd(draws[index].instanceCount, 1);
	
	meshIndexCulled[newid] = meshIndex[gid];
	transformCulled[newid] = transform[gid];
	materialCulled[newid] = material[gid];
}
