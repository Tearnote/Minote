#version 460
#pragma shader_stage(compute)

layout(local_size_x = 64) in;

#include "include/types.glsl"

layout (binding = 0, std430) buffer Draws {
	IndirectCommand draws[];
};
layout (binding = 1, std430) buffer Descriptors {
	MeshDescriptor descriptors[];
};
layout (binding = 2, std430) readonly buffer MeshIndices {
	uint meshIndices[];
};
layout (binding = 3, std430) readonly buffer Transforms {
	Transform transforms[];
};
layout (binding = 4, std430) readonly buffer Materials {
	Material materials[];
};
layout (binding = 5, std430) writeonly buffer MeshIndicesCulled {
	uint meshIndicesCulled[];
};
layout (binding = 6, std430) writeonly buffer TransformsCulled {
	RowTransform transformsCulled[];
};
layout (binding = 7, std430) writeonly buffer MaterialsCulled {
	Material materialsCulled[];
};
layout(binding = 8) uniform CullData {
	mat4 view;
	vec4 frustum;
	uint instancesCount;
};

bool visible(uint gid, float radius) {
	vec3 center = (view * vec4(transforms[gid].position, 1.0)).xyz;

	bool result = true;
	result = result && center.z * frustum[1] - abs(center.x) * frustum[0] > -radius;
	result = result && center.z * frustum[3] - abs(center.y) * frustum[2] > -radius;
	
	return result;
}

void main() {
	const uint gid = gl_GlobalInvocationID.x;
	if (gid >= instancesCount) return;
	
	uint index = meshIndices[gid];
	float scale = max(transforms[gid].scale.x,
	              max(transforms[gid].scale.y,
				      transforms[gid].scale.z));
	float radius = descriptors[index].radius;
	if (!visible(gid, radius * scale)) return;
	
	uint offset = draws[index].firstInstance;
	uint newid = offset + atomicAdd(draws[index].instanceCount, 1);
	
	meshIndicesCulled[newid] = meshIndices[gid];
	transformsCulled[newid] = encodeTransform(transforms[gid]);
	materialsCulled[newid] = materials[gid];
}
