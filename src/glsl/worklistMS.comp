#version 460
#pragma shader_stage(compute)
#extension GL_KHR_shader_subgroup_basic: enable
#extension GL_KHR_shader_subgroup_arithmetic: enable

layout(local_size_x = 8, local_size_y = 8) in;

#include "visibilityTypes.glsl"
#include "visibility.glsl"
#include "types.glsl"

layout(binding = 0) uniform usampler2DMS s_visbuf;
layout(binding = 1, std430) restrict readonly buffer Instances {
	Instance b_instances[];
};
layout(binding = 2, std430) restrict readonly buffer Materials {
	Material b_materials[];
};
layout(binding = 3, std430) restrict buffer TileCounts {
	uvec4 b_counts[];
};
layout(binding = 4, std430) restrict writeonly buffer TileLists {
	uint b_lists[];
};

layout(push_constant) uniform PushConstants {
	uvec2 u_visbufSize;
	uint u_listCount;
	uint u_sampleCount;
};

shared uint sh_result;

void main() {
	
	uvec2 gid = gl_GlobalInvocationID.xy;
	uvec2 lid = gl_LocalInvocationID.xy;
	
	// Initialize shared mem
	
	if (all(equal(lid, uvec2(0))))
		sh_result = 0;
	
	memoryBarrierShared();
	barrier();
	
	uint materials = 0;
	for (uint i = 0; i < u_sampleCount; i += 1) {
		
		// Fetch material id
		
		uint materialID = -1u;
		if (all(lessThan(gid, u_visbufSize))) {
			
			uint visPacked = texelFetch(s_visbuf, ivec2(gid), int(i)).x;
			if (visPacked == -1u) { // Sky
				
				materialID = 0;
				
			} else {
				
				VisSample vis = unpackVisibility(visPacked);
				uint materialIdx = b_instances[vis.instance].materialIdx;
				materialID = b_materials[materialIdx].id;
				
			}
			
		}
		
		// Mark found material
		
		if (materialID != -1u)
			materials |= 1u << materialID;
		
	}
	
	// Combine found materials
	
	uint combined = subgroupOr(materials);
	if (subgroupElect())
		atomicOr(sh_result, combined);
	
	memoryBarrierShared();
	barrier();
	
	// Write tiles
	
	if (any(notEqual(lid, uvec2(0))))
		return;
	
	uint flatGroupSize = gl_WorkGroupSize.x * gl_WorkGroupSize.y;
	uint tileCount = gl_NumWorkGroups.x * gl_NumWorkGroups.y;
	
	for (uint i = 0; i < u_listCount; i += 1) {
		
		if ((sh_result & (1u << i)) == 0u)
			continue;
		
		uint tileOffset = tileCount * i;
		uint tileIdx = atomicAdd(b_counts[i].x, 1);
		
		uint tile = gl_WorkGroupID.x + (gl_WorkGroupID.y << 16u);
		b_lists[tileOffset + tileIdx] = tile;
		
	}
	
}
