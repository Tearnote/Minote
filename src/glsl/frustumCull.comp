#version 460
#pragma shader_stage(compute)

layout(local_size_x = 64) in;

#include "types.glsl"

layout(binding = 0, std430) restrict readonly buffer Commands {
	Command b_commands[];
};
layout(binding = 1) uniform InstanceCount {
	uvec4 u_instanceCount;
};
layout(binding = 2, std430) restrict readonly buffer Instances {
	Instance b_instances[];
};
layout(binding = 3, std430) restrict readonly buffer Transforms {
	mat3x4 b_transforms[];
};
layout(binding = 4, std430) restrict readonly buffer Descriptors {
	MeshDescriptor b_descriptors[];
};
layout(binding = 5, std430) restrict buffer CommandsCulled {
	Command b_commandsCulled[];
};
layout(binding = 6, std430) restrict writeonly buffer InstanceCountCulled {
	uvec4 b_instanceCountCulled;
};
layout(binding = 7, std430) restrict writeonly buffer InstancesCulled {
	Instance b_instancesCulled[];
};

layout(push_constant) uniform Constants {
	mat4 u_view;
	vec4 u_frustum;
	uint u_commandsCount;
};

bool visible(uint _transformIdx, float _radius) {
	
	vec3 position = {
		b_transforms[_transformIdx][0].w,
		b_transforms[_transformIdx][1].w,
		b_transforms[_transformIdx][2].w };
	
	vec3 center = (u_view * vec4(position, 1.0)).xyz;
	
	bool result = true;
	result = result && center.z * u_frustum[1] - abs(center.x) * u_frustum[0] > -_radius;
	result = result && center.z * u_frustum[3] - abs(center.y) * u_frustum[2] > -_radius;
	
	return result;
	
}

void main() {
	
	uint gid = gl_GlobalInvocationID.x;
	if (gid >= u_instanceCount.w)
		return;
	
	// Initialize commands buffer
	
	if (gid == 0) {
		
		for (uint i = 0; i < u_commandsCount; i += 1) {
			
			b_commandsCulled[i].indexCount = b_commands[i].indexCount;
			// instanceCount is filled up during culling
			b_commandsCulled[i].firstIndex = b_commands[i].firstIndex;
			b_commandsCulled[i].vertexOffset = b_commands[i].vertexOffset;
			b_commandsCulled[i].firstInstance = b_commands[i].firstInstance; // We're keeping offset the same for simplicity
			
		}
		
	}
	
	// Determine if instance is culled
	
	uint meshIdx = b_instances[gid].meshIdx;
	uint transformIdx = b_instances[gid].transformIdx;
	float scale = max(length(b_transforms[transformIdx][0].xyz),
	              max(length(b_transforms[transformIdx][1].xyz),
	                  length(b_transforms[transformIdx][2].xyz)));
	float radius = b_descriptors[meshIdx].radius;
	if (!visible(transformIdx, radius * scale))
		return;
	
	// Write instance to culled buffers
	
	uint oldInstanceCount = atomicAdd(b_instanceCountCulled.w, 1);
	if (oldInstanceCount % 64u == 0u)
		atomicAdd(b_instanceCountCulled.x, 1);
	uint offset = b_commands[meshIdx].firstInstance;
	uint newid = offset + atomicAdd(b_commandsCulled[meshIdx].instanceCount, 1);
	
	b_instancesCulled[newid] = b_instances[gid];
	
}
