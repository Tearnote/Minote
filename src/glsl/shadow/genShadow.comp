#version 460
#pragma shader_stage(compute)

layout(local_size_x = 8, local_size_y = 8) in;

#include "../visibility/visbuf.glsl"
#include "../quad/quad.glsl"
#include "../types.glsl"
#include "../util.glsl"

#define B_INDICES b_indices
#define B_VERTICES b_vertices

layout(binding = 0) uniform WorldConstants {
	World u_world;
};

layout (binding = 1, std430) restrict readonly buffer Meshes {
	Mesh b_meshes[];
};
layout (binding = 2, std430) restrict readonly buffer Instances {
	Instance b_instances[];
};
layout(binding = 3, std430) restrict readonly buffer Transforms {
	mat3x4 b_transforms[];
};

layout (binding = 4, std430) restrict readonly buffer Indices {
	uint B_INDICES[];
};
layout (binding = 5, std430) restrict readonly buffer Vertices {
	float B_VERTICES[];
};

layout(binding = 6) uniform usampler2D s_visbuf;
layout(binding = 7) uniform sampler2D s_offset;
layout(binding = 8) uniform sampler2D s_depth;
layout(binding = 9) uniform usampler2D s_normal;
layout(binding = 10) uniform usampler2DMS s_shadowbuf;
layout(binding = 11) restrict writeonly uniform image2D i_shadowOut;

layout(push_constant) uniform Constants {
	mat4 u_shadowViewProjection;
};

layout(constant_id = 0) const uint ShadowbufSizePacked = 0;
layout(constant_id = 1) const uint ShadowOutSizePacked = 0;
const uvec2 ShadowbufSize = uvec2(U16FROMU32(ShadowbufSizePacked));
const uvec2 ShadowOutSize = uvec2(U16FROMU32(ShadowOutSizePacked));

#include "../typesAccess.glsl"

struct Ray
{
    vec3 origin;
    vec3 direction;
};

float intersect_triangle_dist

	(Ray   ray,  /* ray for the intersection */
	 vec3  v0,   /* vertex 0 */
	 vec3  v1,   /* vertex 1 */
	 vec3  v2    /* vertex 2 */
	)
	 
/*
	Returns true if there is an intersection with the triangle (v0,v1,v2).
	The intersection is accepted if it is in (mint, maxt) along the ray.
	Uses the metric tensor for intersection computation.
	
	For the derivation see the appendix.
*/

{	
	/* edges and non-normalized normal */
	vec3 e0 = v1-v0;
	vec3 e1 = v2-v0;
	vec3 n = cross(e0,e1);
	
	/* intersect plane in which the triangle is situated */
	return dot(v0-ray.origin,n) / dot(ray.direction,n);
	
} /* intersect_triangle_any_fast */

// signed distance to a 2D triangle
float sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )
{
	vec2 e0 = p1 - p0;
	vec2 e1 = p2 - p1;
	vec2 e2 = p0 - p2;

	vec2 v0 = p - p0;
	vec2 v1 = p - p1;
	vec2 v2 = p - p2;

	vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );
	vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );
	vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );
    
    float s = e0.x*e2.y - e0.y*e2.x;
    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),
                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),
                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));

	return -sqrt(d.x)*sign(d.y);
}

void main() {
	
	uvec2 gid = gl_GlobalInvocationID.xy;
	if (any(greaterThanEqual(gid, ShadowOutSize)))
		return;
	
	float result = 1.0;
	uint visbuf = texelFetch(s_visbuf, ivec2(gid), 0).x;
	if (visbuf != -1u) { // Valid triangle cluster
		
		vec2 clusterCentroid = texelFetch(s_offset, ivec2(gid), 0).xy * 2.0;
		
		float depth = texelFetch(s_depth, ivec2(gid), 0).x;
		vec2 clusterPos = vec2(gid & ~1u) + clusterCentroid;
		vec2 screenUv = clusterPos / vec2(ShadowOutSize);
		vec3 clipPos = vec3(screenUv * 2.0 - 1.0, depth);
		
		vec4 worldVertexW = u_world.viewProjectionInverse * vec4(clipPos, 1.0);
		vec3 worldVertex = worldVertexW.xyz / worldVertexW.w;
		
		uint normalOct = texelFetch(s_normal, ivec2(gid), 0).x;
		vec3 normal = octDecode(normalOct);
		
		vec4 shadowVertexW = (u_shadowViewProjection * u_world.viewProjectionInverse) * vec4(clipPos, 1.0);
		vec3 shadowVertex = shadowVertexW.xyz / shadowVertexW.w;
		vec2 shadowUv = shadowVertex.xy * 0.5 + 0.5;
		vec2 shadowPos = shadowUv * ShadowbufSize;
		
		if (dot(normal, u_world.sunDirection) < 0.0) {
			
			result = 0.0;
			
		} else {
			
			for (uint x = 0; x < 2; x += 1)
			for (uint y = 0; y < 2; y += 1)
			for (uint z = 0; z < 8; z += 1) {
				
				uvec2 shadowCoord = uvec2(shadowPos) + uvec2(x, y) - uvec2(1);
				if (fract(shadowPos.x) - QuadSubsampleLocations[z].x < -0.5)
					shadowCoord.x -= 1;
				if (fract(shadowPos.x) - QuadSubsampleLocations[z].x > 0.5)
					shadowCoord.x += 1;
				if (fract(shadowPos.y) - QuadSubsampleLocations[z].y < -0.5)
					shadowCoord.y -= 1;
				if (fract(shadowPos.y) - QuadSubsampleLocations[z].y > 0.5)
					shadowCoord.y += 1;
				if (any(greaterThanEqual(shadowCoord, ShadowbufSize)))
					continue;
				
				uint shadowValue = texelFetch(s_shadowbuf, ivec2(shadowCoord), int(z)).x;
				if (shadowValue == -1u)
					continue;
				
				VisSample shadowVis = unpackVisibility(shadowValue);
				Instance instance = b_instances[shadowVis.instance];
				uint meshIdx = instance.meshIdx;
				Mesh mesh = b_meshes[meshIdx];
				
				uint indexBase = mesh.indexOffset;
				indexBase += shadowVis.triangle * 3;
				uvec3 indices = fetchIndices(indexBase);
				
				mat4 meshTransform = b_meshes[meshIdx].transform;
				uint transformIdx = instance.objectIdx;
				mat4 transform = getTransform(b_transforms[transformIdx]) * meshTransform;
				transform = u_shadowViewProjection * transform;
				
				mat3 vertices = {
					fetchVertex(indices.x),
					fetchVertex(indices.y),
					fetchVertex(indices.z) };
				for (uint i = 0; i < 3; i += 1) {
					
					vec4 transformed = transform * vec4(vertices[i], 1.0);
					vertices[i] = transformed.xyz / transformed.w;
					
				}
				
				Ray ray;
				ray.origin = shadowVertex;
				ray.direction = vec3(0.0, 0.0, 1.0);
				float depthDiff = intersect_triangle_dist(ray, vertices[0], vertices[1], vertices[2]);
				float dist = sdTriangle(shadowVertex.xy, vertices[0].xy, vertices[1].xy, vertices[2].xy) / 2.0 * ShadowbufSize.x;
				dist -= 0.5;
				
				if (depthDiff > 0.00002)
					result = min(result, clamp(dist * 4 + 0.5, 0.0, 1.0));
				
			}
			
		}
		
	}
	
	imageStore(i_shadowOut, ivec2(gid), vec4(result, 0.0, 0.0, 0.0));
	
}
