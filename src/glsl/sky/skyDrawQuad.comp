#version 460
#pragma shader_stage(compute)

layout(local_size_x = 1, local_size_y = 64) in;

#include "skyTypes.glsl"
#include "../types.glsl"
#include "../util.glsl"

#define U_ATMO u_atmo
#define S_TRANSMITTANCE s_transmittance
#define B_LISTS b_lists

layout(binding = 0) uniform WorldConstants {
	World u_world;
};
layout(binding = 1) uniform Atmosphere {
	AtmosphereParams U_ATMO;
};
layout(binding = 2) uniform sampler2D S_TRANSMITTANCE;
layout(binding = 3) uniform sampler2D s_skyView;
layout(binding = 4, std430) restrict readonly buffer TileLists {
	uint B_LISTS[];
};
layout(binding = 5) uniform usampler2D s_clusterDef;
layout(binding = 6) writeonly uniform image2D i_clusterOut;

layout(constant_id = 0) const uint SkyViewSizePacked = 0;
layout(constant_id = 1) const uint TargetSizePacked = 0;
layout(constant_id = 2) const uint TileOffset = 0;

const uvec2 SkyViewSize = U16FROMU32(SkyViewSizePacked);
const uvec2 TargetSize = U16FROMU32(TargetSizePacked);

#include "sky.glsl"
#include "../worklist.glsl"
#include "../quad.glsl"

vec3 shadeSkySample(vec2 _gid) {
	
	vec2 gUv = _gid / vec2(TargetSize);
	vec3 clipSpace = vec3(gUv * vec2(2.0) - vec2(1.0), 0.0);
	vec4 hPos = u_world.viewProjectionInverse * vec4(clipSpace, 1.0);
	
	vec3 worldDir = normalize(hPos.xyz);
	vec3 worldPos = u_world.cameraPos + vec3(0.0, 0.0, u_atmo.bottomRadius);
	
	float viewHeight = length(worldPos);
	
	vec2 uv;
	vec3 upVector = normalize(worldPos);
	float viewZenithCosAngle = dot(worldDir, upVector);
	
	vec3 sideVector = normalize(cross(upVector, worldDir)); // assumes non parallel vectors
	vec3 forwardVector = normalize(cross(sideVector, upVector)); // aligns toward the sun light but perpendicular to up vector
	vec2 lightOnPlane = vec2(dot(u_world.sunDirection, forwardVector), dot(u_world.sunDirection, sideVector));
	lightOnPlane = normalize(lightOnPlane);
	float lightViewCosAngle = lightOnPlane.x;
	
	bool intersectGround = (raySphereIntersectNearest(worldPos, worldDir, vec3(0.0), u_atmo.bottomRadius) >= 0.0);
	
	skyViewLutParamsToUv(intersectGround, viewZenithCosAngle, lightViewCosAngle, SkyViewSize, viewHeight, uv, u_atmo.bottomRadius);
	vec3 skyView = textureLod(s_skyView, uv, 0.0).rgb;
	vec3 sun = getSunLuminance(worldPos, worldDir, u_world.sunDirection, u_world.sunIlluminance)
		* (120000.0 / u_world.sunIlluminance);
	
	return skyView + sun;
	
}

void main() {
	
	uvec2 lid = mortonOrder(gl_LocalInvocationID.y);
	uvec2 gid = getTileGid(gl_WorkGroupID.x, TileOffset) + lid;
	
	// Retrieve cluster data
	
	uvec2 quadbufSample;
	if (all(lessThan(gid, TargetSize)))
		quadbufSample = texelFetch(s_clusterDef, ivec2(gid), 0).xy;
	else
		quadbufSample = uvec2(0u, 0u);
	
	// Shade the cluster
	
	uint clusterValue = quadbufSample.x;
	uint clusterSubsamples = quadbufSample.y;
	vec3 clusterResult;
	if (clusterValue == -1u && clusterSubsamples != 0) {
		
		vec2 clusterCentroid = subsamplePosAverage(clusterSubsamples);
		clusterResult = shadeSkySample(vec2(gid & ~1u) + clusterCentroid);
		imageStore(i_clusterOut, ivec2(gid), vec4(clusterResult, 1.0));
		
	}
	
}
