#version 460
#pragma shader_stage(compute)

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "skyTypes.glsl"
#include "../types.glsl"
#include "../util.glsl"

#define U_ATMO u_atmo
#define S_TRANSMITTANCE s_transmittance
#define S_MULTISCATTERING s_multiscattering

layout(binding = 0) uniform WorldConstants {
	World u_world;
};
layout(binding = 1) uniform Atmosphere {
	AtmosphereParams U_ATMO;
};
layout(binding = 2) uniform sampler2D S_TRANSMITTANCE;
layout(binding = 3) uniform sampler2D S_MULTISCATTERING;
layout(binding = 4) restrict writeonly uniform image3D i_aerialPerspective;

layout(push_constant) uniform Constants {
	float4x4 u_invViewProj;
	float3 u_probePosition;
};

layout(constant_id = 0) const uint AerialPerspectiveSizeXYPacked = 0;
layout(constant_id = 1) const uint AerialPerspectiveSizeZ = 0;

const uint3 AerialPerspectiveSize = uint3(U16FROMU32(AerialPerspectiveSizeXYPacked), AerialPerspectiveSizeZ);

#include "sky.glsl"

void main() {
	
	uint3 gid = gl_GlobalInvocationID;

	if (any(greaterThanEqual(gid, AerialPerspectiveSize)))
		return;

	float2 pixPos = float2(gid) + float2(0.5);
	float3 clipSpace = float3((pixPos / float2(AerialPerspectiveSize.xy)) * float2(2.0) - float2(1.0), 0.0);
	float4 hPos = u_invViewProj * float4(clipSpace, 1.0);
	float3 worldDir = normalize(hPos.xyz);
	float earthR = u_atmo.bottomRadius;
	float3 earthO = float3(0.0, 0.0, -earthR);
	float3 camPos = u_probePosition + float3(0.0, 0.0, earthR);
	float3 sunDir = u_world.sunDirection;
	float3 sunLuminance = float3(0.0);

	float slice = ((float(gid.z) + 0.5) / AerialPerspectiveSize.z);
	slice *= slice;	// squared distribution
	slice *= AerialPerspectiveSize.z;

	float3 worldPos = camPos;
	float viewHeight;
	
	// Compute position from froxel information
	float tMax = aerialPerspectiveSliceToDepth(slice);
	float3 newWorldPos = worldPos + tMax * worldDir;
	
	// If the voxel is under the ground, make sure to offset it out of the ground.
	viewHeight = length(newWorldPos);
	if (viewHeight <= (u_atmo.bottomRadius + PLANET_RADIUS_OFFSET)) {
		
		// Apply a position offset to make sure no artefact are visible close to the earth boundaries for large voxel.
		newWorldPos = normalize(newWorldPos) * (u_atmo.bottomRadius + PLANET_RADIUS_OFFSET + 0.001);
		worldDir = normalize(newWorldPos - camPos);
		tMax = length(newWorldPos - camPos);
		
	}
	float tMaxMax = tMax;
	
	// Move ray marching start up to top atmosphere.
	viewHeight = length(worldPos);
	if (viewHeight >= u_atmo.topRadius) {
		
		float3 prevWorldPos = worldPos;
		if (!moveToTopAtmosphere(worldPos, worldDir, u_atmo.topRadius)) {
			
			// Ray is not intersecting the atmosphere
			imageStore(i_aerialPerspective, int3(gid), float4(0.0, 0.0, 0.0, 1.0));
			return;
			
		}
		float lengthToAtmosphere = length(prevWorldPos - worldPos);
		if (tMaxMax < lengthToAtmosphere) {
			
			// tMaxMax for this voxel is not within earth atmosphere
			imageStore(i_aerialPerspective, int3(gid), float4(0.0, 0.0, 0.0, 1.0));
			return;
			
		}
		// Now world position has been moved to the atmosphere boundary: we need to reduce tMaxMax accordingly.
		tMaxMax = max(0.0, tMaxMax - lengthToAtmosphere);
	}
	
	bool ground = false;
	float sampleCountIni = max(1.0, float(gid.z + 1.0) * 2.0);
	bool variableSampleCount = false;
	bool mieRayPhase = true;
	SingleScatteringResult ss = integrateScatteredLuminance(worldPos, worldDir, sunDir,
		ground, sampleCountIni, variableSampleCount, mieRayPhase, tMaxMax, u_world.sunIlluminance);
	
	float transmittance = dot(ss.transmittance, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));
	imageStore(i_aerialPerspective, int3(gid), float4(ss.L, 1.0 - transmittance));
	
}
