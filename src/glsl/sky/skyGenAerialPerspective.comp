#version 460
#pragma shader_stage(compute)

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 1, binding = 0, rgba16f) restrict writeonly uniform image3D aerialPerspective;

#define SKY_USE_WORLD
#define MULTIPLE_SCATTERING_ENABLED 1
#include "sky.glsl"

void main() {
	const uvec3 gid = gl_GlobalInvocationID;
	const ivec3 size = imageSize(aerialPerspective);

	if (any(greaterThanEqual(gid, size)))
		return;

	vec2 PixPos = vec2(gid) + vec2(0.5);
	vec3 ClipSpace = vec3((PixPos / vec2(size.xy)) * vec2(2.0, 2.0) - vec2(1.0, 1.0), 0.0);
	vec4 HPos = world.viewProjectionInverse * vec4(ClipSpace, 1.0);
	vec3 WorldDir = normalize(HPos.xyz);
	float earthR = Atmosphere.BottomRadius;
	vec3 earthO = vec3(0.0, 0.0, -earthR);
	vec3 camPos = world.cameraPos + vec3(0.0, 0.0, earthR);
	vec3 SunDir = world.sunDirection;
	vec3 SunLuminance = vec3(0.0);

	float Slice = ((float(gid.z) + 0.5) / size.z);
	Slice *= Slice;	// squared distribution
	Slice *= size.z;

	vec3 WorldPos = camPos;
	float viewHeight;

	// Compute position from froxel information
	float tMax = AerialPerspectiveSliceToDepth(Slice);
	vec3 newWorldPos = WorldPos + tMax * WorldDir;

	// If the voxel is under the ground, make sure to offset it out of the ground.
	viewHeight = length(newWorldPos);
	if (viewHeight <= (Atmosphere.BottomRadius + PLANET_RADIUS_OFFSET)) {
		// Apply a position offset to make sure no artefact are visible close to the earth boundaries for large voxel.
		newWorldPos = normalize(newWorldPos) * (Atmosphere.BottomRadius + PLANET_RADIUS_OFFSET + 0.001);
		WorldDir = normalize(newWorldPos - camPos);
		tMax = length(newWorldPos - camPos);
	}
	float tMaxMax = tMax;

	// Move ray marching start up to top atmosphere.
	viewHeight = length(WorldPos);
	if (viewHeight >= Atmosphere.TopRadius) {
		vec3 prevWorlPos = WorldPos;
		if (!MoveToTopAtmosphere(WorldPos, WorldDir, Atmosphere.TopRadius)) {
			// Ray is not intersecting the atmosphere
			imageStore(aerialPerspective, ivec3(gid), vec4(0.0, 0.0, 0.0, 1.0));
			return;
		}
		float LengthToAtmosphere = length(prevWorlPos - WorldPos);
		if (tMaxMax < LengthToAtmosphere) {
			// tMaxMax for this voxel is not within earth atmosphere
			imageStore(aerialPerspective, ivec3(gid), vec4(0.0, 0.0, 0.0, 1.0));
			return;
		}
		// Now world position has been moved to the atmosphere boundary: we need to reduce tMaxMax accordingly.
		tMaxMax = max(0.0, tMaxMax - LengthToAtmosphere);
	}

	const bool ground = false;
	const float SampleCountIni = max(1.0, float(gid.z + 1.0) * 2.0);
	const bool VariableSampleCount = false;
	const bool MieRayPhase = true;
	SingleScatteringResult ss = IntegrateScatteredLuminance(WorldPos, WorldDir, SunDir,
	ground, SampleCountIni, VariableSampleCount, MieRayPhase, tMaxMax, world.sunIlluminance);


	const float Transmittance = dot(ss.Transmittance, vec3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));
	imageStore(aerialPerspective, ivec3(gid), vec4(ss.L, 1.0 - Transmittance));
}
