#version 460
#pragma shader_stage(compute)

layout(local_size_x = 8, local_size_y = 8) in;

#include "skyTypes.glsl"
#include "../types.glsl"
#include "../util.glsl"

#define U_ATMO u_atmo
#define S_TRANSMITTANCE s_transmittance

layout(binding = 0) uniform WorldConstants {
	World u_world;
};
layout(binding = 1) uniform Atmosphere {
	AtmosphereParams U_ATMO;
};
layout(binding = 2) uniform sampler2D S_TRANSMITTANCE;
layout(binding = 3) uniform sampler2D s_skyView;
layout(binding = 4) restrict writeonly uniform imageCube i_cubemap;
layout(binding = 5) uniform Sides {
	float4x4 u_sides[6];
};

layout(push_constant) uniform Constants {
	float3 u_probePosition;
};

layout(constant_id = 0) const uint SkyViewSizePacked = 0;
layout(constant_id = 1) const uint CubemapSize = 0;

const uint2 SkyViewSize = U16FROMU32(SkyViewSizePacked);

#include "sky.glsl"

void main() {
	
	uint3 gid = gl_GlobalInvocationID;
	
	float2 cubeUv = (float2(gid.xy) + float2(0.5)) / float2(float(CubemapSize));
	cubeUv = cubeUv * 2.0 - 1.0;
	float3 dir = float3x3(u_sides[gid.z]) * float3(cubeUv, 1.0);
	
	float3 worldDir = normalize(dir);
	float3 worldPos = u_probePosition + float3(0.0, 0.0, u_atmo.bottomRadius);
	
	float viewHeight = length(worldPos);
	
	float2 uv;
	float3 upVector = normalize(worldPos);
	float viewZenithCosAngle = dot(worldDir, upVector);
	
	float3 sideVector = normalize(cross(upVector, worldDir)); // assumes non parallel vectors
	float3 forwardVector = normalize(cross(sideVector, upVector)); // aligns toward the sun light but perpendicular to up vector
	float2 lightOnPlane = float2(dot(u_world.sunDirection, forwardVector), dot(u_world.sunDirection, sideVector));
	lightOnPlane = normalize(lightOnPlane);
	float lightViewCosAngle = lightOnPlane.x;
	
	bool intersectGround = (raySphereIntersectNearest(worldPos, worldDir, float3(0.0), u_atmo.bottomRadius) >= 0.0);
	
	skyViewLutParamsToUv(intersectGround, viewZenithCosAngle, lightViewCosAngle, SkyViewSize, viewHeight, uv, u_atmo.bottomRadius);
	float4 result = float4(textureLod(s_skyView, uv, 0.0).rgb, 1.0);
	imageStore(i_cubemap, int3(gid), result);
	
}
