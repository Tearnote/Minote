#version 460
#pragma shader_stage(compute)

layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 1, binding = 0, r11f_g11f_b10f) restrict writeonly uniform image2D skyView;

#define MULTIPLE_SCATTERING_ENABLED 1
#include "sky.glsl"

void main() {
	const uvec2 gid = gl_GlobalInvocationID.xy;
	const ivec2 size = imageSize(skyView);

	if (any(greaterThanEqual(gid, size)))
		return;

	vec2 pixPos = vec2(gid) + vec2(0.5);

	vec3 ClipSpace = vec3((pixPos / vec2(size)) * vec2(2.0, -2.0) - vec2(1.0, -1.0), 1.0);
	vec4 HPos = world.viewProjectionInverse * vec4(ClipSpace, 1.0);

	vec3 WorldDir = normalize(HPos.xyz / HPos.w - camera);
	vec3 WorldPos = camera + vec3(0, 0, Atmosphere.BottomRadius);

	vec2 uv = pixPos / vec2(size);

	float viewHeight = length(WorldPos);

	float viewZenithCosAngle;
	float lightViewCosAngle;
	UvToSkyViewLutParams(viewZenithCosAngle, lightViewCosAngle, size, viewHeight, uv);

	vec3 SunDir;
	{
		vec3 UpVector = WorldPos / viewHeight;
		float sunZenithCosAngle = dot(UpVector, sun_direction);
		SunDir = normalize(vec3(sqrt(1.0 - sunZenithCosAngle * sunZenithCosAngle), 0.0, sunZenithCosAngle));
	}

	WorldPos = vec3(0.0, 0.0, viewHeight);

	float viewZenithSinAngle = sqrt(1 - viewZenithCosAngle * viewZenithCosAngle);
	WorldDir = vec3(
		viewZenithSinAngle * lightViewCosAngle,
		viewZenithSinAngle * sqrt(1.0 - lightViewCosAngle * lightViewCosAngle),
		viewZenithCosAngle);


	// Move to top atmosehere
	if (!MoveToTopAtmosphere(WorldPos, WorldDir, Atmosphere.TopRadius)) {
		// Ray is not intersecting the atmosphere
		imageStore(skyView, ivec2(gid), vec4(0.0, 0.0, 0.0, 1.0));
		return;
	}

	const bool ground = false;
	const float SampleCountIni = 30;
	const bool VariableSampleCount = true;
	const bool MieRayPhase = true;
	SingleScatteringResult ss = IntegrateScatteredLuminance(WorldPos, WorldDir, SunDir,
	ground, SampleCountIni, VariableSampleCount, MieRayPhase, 9000000.0);

	vec3 L = ss.L;
	imageStore(skyView, ivec2(gid), vec4(L, 1.0));
}
