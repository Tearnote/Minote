#version 460
#pragma shader_stage(compute)

layout(local_size_x = 8, local_size_y = 8) in;

#include "../world.glsl"
#include "sky.glsl"

layout(binding = 0) uniform WorldConstants {
	World world;
};

layout(set = 1, binding = 0) uniform sampler2D skyView;
layout(set = 1, binding = 1, rgba16f) restrict writeonly uniform imageCube cubemap;
layout(set = 1, binding = 2) uniform Sides {
	mat4 sides[6];
};
layout(set = 1, binding = 3) restrict writeonly buffer SunLuminance {
	vec3 sunLuminance;
};
layout(push_constant) uniform ProbePosition {
	vec3 probePosition;
};

void main() {
	const uvec3 gid = gl_GlobalInvocationID;
	const ivec2 cubeSize = imageSize(cubemap);
	const ivec2 viewSize = textureSize(skyView, 0);

	vec2 cubeUv = (vec2(gid.xy) + vec2(0.5)) / vec2(cubeSize);
	cubeUv = cubeUv * 2.0 - 1.0;
	vec3 dir = mat3(sides[gid.z]) * vec3(cubeUv, 1.0);

	vec3 WorldDir = normalize(dir);
	vec3 WorldPos = probePosition + vec3(0.0, 0.0, Atmosphere.BottomRadius);

	float viewHeight = length(WorldPos);

	vec2 uv;
	vec3 UpVector = normalize(WorldPos);
	float viewZenithCosAngle = dot(WorldDir, UpVector);

	vec3 sideVector = normalize(cross(UpVector, WorldDir)); // assumes non parallel vectors
	vec3 forwardVector = normalize(cross(sideVector, UpVector)); // aligns toward the sun light but perpendicular to up vector
	vec2 lightOnPlane = vec2(dot(world.sunDirection, forwardVector), dot(world.sunDirection, sideVector));
	lightOnPlane = normalize(lightOnPlane);
	float lightViewCosAngle = lightOnPlane.x;

	bool IntersectGround = raySphereIntersectNearest(WorldPos, WorldDir, vec3(0.0), Atmosphere.BottomRadius) >= 0.0;

	SkyViewLutParamsToUv(IntersectGround, viewZenithCosAngle, lightViewCosAngle, viewSize, viewHeight, uv);
	vec4 result = vec4(textureLod(skyView, uv, 0.0).rgb, 1.0);
	imageStore(cubemap, ivec3(gid), result);
	
	// if (all(equal(gid, uvec3(0)))) {
	// 	vec3 sun = GetSunLuminance(WorldPos, world.sunDirection, Atmosphere.BottomRadius);
	// 	sunLuminance = sun;
	// }
	vec3 sun = GetSunLuminance(WorldPos, world.sunDirection, Atmosphere.BottomRadius, world.sunDirection, world.sunIlluminance);
	if (any(notEqual(sun, vec3(0.0))))
		sunLuminance = sun;
}
