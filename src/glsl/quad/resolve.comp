#version 460
#pragma shader_stage(compute)

layout(local_size_x = 8, local_size_y = 8) in;

#include "../types.glsl"
#include "../util.glsl"
#include "quad.glsl"

layout(binding = 0) uniform WorldConstants {
	World u_world;
};
layout(binding = 1) uniform usampler2D s_subsamples;
layout(binding = 2) uniform usampler2D s_jitterMap;
layout(binding = 3) uniform sampler2D s_clusterOut;
layout(binding = 4) uniform sampler2D s_outputPrev;
layout(binding = 5) uniform sampler2D s_velocity;
layout(binding = 6) uniform sampler2D s_quadDepthRepro;
layout(binding = 7) uniform sampler2D s_quadDepthPrev;
layout(binding = 8) restrict writeonly uniform image2D i_output;

layout(constant_id = 0) const uint u_sourceSizePacked = 0;
const uint2 u_sourceSize = U16FROMU32(u_sourceSizePacked);

#define CONVERGE_FRAMES 16

bool isQuadJittered(usampler2D _map, uint2 _gid) {
	
	uint jitterSample = texelFetch(_map, int2(_gid / 8), 0).r;
	uint2 quadOffset = (_gid / 2) % 4;
	uint quadMask = 1u << (quadOffset.x + quadOffset.y * 4);
	return (jitterSample & quadMask) != 0;
	
}

// https://research.activision.com/publications/archives/filmic-smaasharp-morphological-and-temporal-antialiasing
#define REPROJECTION_SHARPNESS 25.0
float4 sampleHistory(float2 _uv) {
	
	const float2 sourcePxPitch = float2(1.0) / float2(u_sourceSize);
	
	float2 centerPosition = floor(_uv - 0.5) + 0.5;
	float2 f = _uv - centerPosition;
	float2 f2 = f * f;
	float2 f3 = f * f2;
	
	float c = REPROJECTION_SHARPNESS / 100.0;
	float2 w0 =        -c  * f3 +  2.0 * c         * f2 - c * f;
	float2 w1 =  (2.0 - c) * f3 - (3.0 - c)        * f2         + 1.0;
	float2 w2 = -(2.0 - c) * f3 + (3.0 -  2.0 * c) * f2 + c * f;
	float2 w3 =         c  * f3 -                c * f2;
	
	float2 w12 = w1 + w2;
	float2 tc12 = sourcePxPitch * (centerPosition + w2 / w12);
	float4 centerColor = textureLod(s_outputPrev, float2(tc12.x, tc12.y), 0.0);
	
	float2 tc0 = sourcePxPitch * (centerPosition - 1.0);
	float2 tc3 = sourcePxPitch * (centerPosition + 2.0);
	float3 color = textureLod(s_outputPrev, float2(tc12.x, tc0.y ), 0.0).rgb * (w12.x * w0.y ) +
	             textureLod(s_outputPrev, float2(tc0.x,  tc12.y), 0.0).rgb * (w0.x  * w12.y) +
	             centerColor.rgb                                         * (w12.x * w12.y) +
	             textureLod(s_outputPrev, float2(tc3.x,  tc12.y), 0.0).rgb * (w3.x  * w12.y) +
	             textureLod(s_outputPrev, float2(tc12.x, tc3.y ), 0.0).rgb * (w12.x * w3.y );
	return float4(color.rgb, centerColor.a);
	
}

void main() {
	
	uint2 gid = gl_GlobalInvocationID.xy * 2;
	
	// Read quad and cluster output samples
	
	uint4 clusterSubsamples;
	float4x4x3 clusterOuts;
	float4x4x2 clusterVelocities;
	for (uint i = 0; i < 4; i += 1) {
		
		uint2 pos = gid + uint2(QuadPixelOffsets[i]);
		clusterSubsamples[i] = texelFetch(s_subsamples, int2(pos), 0).x;
		clusterOuts[i] = texelFetch(s_clusterOut, int2(pos), 0).rgb;
		clusterVelocities[i] = texelFetch(s_velocity, int2(pos), 0).xy;
		
	}
	
	// For each pixel, perform TAA
	
	for (uint i = 0; i < 4; i += 1) {
		
		// Calculate each cluster's contribution to current pixel
		
		const float WeightStep = 1.0 / float(SUBSAMPLE_COUNT);
		uint mask = bitmask(SUBSAMPLE_COUNT) << (i * SUBSAMPLE_COUNT);
		float4 clusterWeights;
		for (uint j = 0; j < 4; j += 1)
			clusterWeights[j] = float(bitCount(clusterSubsamples[j] & mask)) * WeightStep;
		
		// Blend together the cluster contributions to obtain current sample
		
		float3 currentSample = float3(0.0);
		for (uint j = 0; j < 4; j += 1)
			currentSample += tonemapWithWeight(clusterOuts[j], clusterWeights[j]);
		currentSample = tonemapInvert(currentSample);
		
		// Reproject to get history position
		
		float2 currentLocation = float2(gid + QuadPixelOffsets[i]) + float2(0.5);
		float2 historyLocation = currentLocation - clusterVelocities[i];
		uint2 historyQuad = uint2(historyLocation) & ~1u;
		
		// History rejection tests
		
		bool reject = true;
		
		// OOB test
		if (all(greaterThanEqual(historyLocation, float2(0.0))) && all(lessThan(historyLocation, float2(u_sourceSize)))) {
			
			// Current jitter test
			
			bool doesJitter = isQuadJittered(s_jitterMap, uint2(currentLocation));
			
			float depthRepro = u_world.nearPlane / texelFetch(s_quadDepthRepro, int2(historyLocation) / 2, 0).x;
			float depthPrev = u_world.nearPlane / texelFetch(s_quadDepthPrev, int2(historyLocation) / 2, 0).x;
			float depthAbsError = abs(depthRepro - depthPrev);
			bool depthPass = depthAbsError < 0.001;
			bool movementPass = all(lessThan(abs(clusterVelocities[i]), float2(0.1)));
			
			if (doesJitter && (depthPass || movementPass))
				reject = false;
			
		}
		
		float4 result; // .a is age
		
		// All clusters valid? Sample the history
		
		float4 historySample = sampleHistory(historyLocation);
		uint historySampleAge = uint(historySample.a);
		if (reject)
			historySampleAge /= 4;
		float blendRatio = (1.0 / float(CONVERGE_FRAMES)) * (CONVERGE_FRAMES - min(historySampleAge, CONVERGE_FRAMES - 1));
		uint newAge = min(historySampleAge + 1, CONVERGE_FRAMES - 1);
		result = float4(mix(historySample.rgb, currentSample, blendRatio), float(newAge));
		
		// Dither and write out
		
		uint2 pos = gid + uint2(QuadPixelOffsets[i]);
		uint seed = u_sourceSize.x * u_sourceSize.y * u_world.frameCounter + pos.x * u_sourceSize.y + pos.y;
		result += (randFloat(seed) * 2.0 - 1.0) * 0.0005;
		result = max(result, 0.0);
		
		imageStore(i_output, int2(gid + QuadPixelOffsets[i]), result);
		
	}
	
}
